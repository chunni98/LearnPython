- [7.1 slots](#71-slots)
- [7.2 @property](#72-property)
- [7.3 多继承](#73-多继承)
- [7.4 定制类](#74-定制类)
- [7.5 枚举类](#75-枚举类)
- [7.6 元类](#76-元类)
  - [7.6.1 type()](#761-type)
  - [7.6.2 metaclass](#762-metaclass)

## 7.1 slots

```python
from types import MethodType                              
                                                          
class Student(object):                                    
    pass                                                  
                                                          
s = Student()                                             
s.name = "chunni" # 给实例绑定一个属性。                  
print(s.name)                                             
                                                          
def set_age(self, age):                                   
    self.age = age                                        
    return None                                           
                                                          
s.set_age = MethodType(set_age, s) #  # 给实例绑定一个方法
s.set_age(19)                                             
print(hasattr(s, "age"))
```

但是，给一个实例绑定的方法，对另一个实例是不起作用的。

为了给所有实例都绑定方法，可以给class绑定方法：

```python
Student.set_score = set_score
```

给class绑定方法后，所有实例均可调用。

**使用 slots**

为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：

```python
class Student(object):
    __slots__ = ("name", "age")

s = Student()
s.name = "Chunni"
```
使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。

除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__和父类的__slots__的并集。

## 7.2 @property

@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。


```python
class Student(object):
    def __init__(self, name: str, age: int):
        self.__name = name
        self.__age = age
        return None
    
    def get_name(self)->str:
        return self.__name
    
    def set_name(self, name: str):
        if not isinstance(name, str):
            raise ValueError('score must be an str!')
        else:
            self.__name = name
        
    def get_age(self)->int:
        return self.__age
    
    def set_age(self, age: int):
        if not isinstance(age, int):
            raise ValueError('score must be an integer!')
        if age < 0 or age > 100:
            raise ValueError('score must between 0 ~ 100!')
        self.__age = age

s = Student("chunni", 23)
print(s.get_age(), s.get_name())
s.set_age(24)
s.set_name("karl")
print(s.get_age(), s.get_name())
```

Python内置的@property装饰器就是负责把一个方法变成属性调用的。

```python
class Student(object):
    def __init__(self, name: str, age: int):
        self.__name = name
        self.__age = age
        return None

    @property
    def name(self)->str:
        return self.__name
    
    @name.setter
    def name(self, name: str):
        if not isinstance(name, str):
            raise ValueError('score must be an str!')
        else:
            self.__name = name
    
    @property
    def age(self)->int:
        return self.__age


s = Student("chunni", 23)

print(s.age, s.name)
# s.age =13 # age 只读
s.name = "karl"
print(s.age, s.name)
```

要特别注意：**属性的方法名不要和实例变量重名。**例如，以下的代码是错误的：

```python
class Student(object):

    # 方法名称和实例变量均为birth:
    @property
    def birth(self):
        return self.birth
```

这是因为调用s.birth时，首先转换为方法调用，在执行return self.birth时，又视为访问self的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错RecursionError。

## 7.3 多继承

```python
class Bat(Mammal, Flyable):
    pass
```

**MixIn**

在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。

MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

多继承如果多个类有共同的方法名，调用该方法的时候，**会调用第一顺位继承父类的方法**。

Python子类的method中调用super()，可以根据继承顺序，把对应父类的method依次调用一次。


**多继承的构造函数**

```python
class Human:
    def __init__(self, sex):
        self.sex = sex
        print("human")
 
class Person:
    def __init__(self, name):
        self.name = name
        print("Person")
 
class Teacher(Person):
    def __init__(self, name, age):
        super().__init__(name)
        self.age = age
        print("Person-Teacher")

class Son(Human, Teacher):
    def __init__(self, sex, name, age, fan):
        Human.__init__(self,sex)
        Teacher.__init__(self, name, age)
        self.fan = fan
        print("human,teacher-son")
    
obj2 = Son("female","chunni", 13, 23)
```

## 7.4 定制类

`__len__()` 方法可以让 `len()` 作用于 class 实例。

`__str__()` 方法可以自定义返回给用户看到的字符串。

```python
class Student(object):
    def __init__(self, name: str) -> None:
        self.__name = name
        return None
    
    def __str__(self) -> str:
        return 'Student object (name: %s)' % self.__name

print(Student("Mike")) # <__main__.Student object at 0x7ff46f1ebdf0>
# 没有自定义 __str__ 的话，打印： <__main__.Student object at 0x7ff46f1ebdf0>
```

`__repr__()` 方法可以自定义调试时候看到的字符串。

```python
class Student(object):
    def __init__(self, name: str) -> None:
        self.__name = name
        return None
    
    def __str__(self) -> str:
        return 'Student object (name: %s)' % self.__name
    
    # 通常可以这样写
    __repr__ = __str__
```

`__iter__()`、`__next__()`

如果一个类想被用于 `for ... in` 循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。

```python
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值

for i in Fib():
    print(i)
```

`__getitem__()`

实现就可以按下标访问数列的任意一项。

```python
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
```

为了支持 slice，要对参数做判断，传入的参数可能是一个 slice 对象：

```python
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L

f = Fib()
print(f[1:5])
# 没有对 step 参数处理：
f[1:10:2]
```

与之对应的是`__setitem__()`方法，把对象视作list或dict来对集合赋值。

最后，还有一个`__delitem__()`方法，用于删除某个元素。

`__getattr__()`

正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。

Python有另一个机制，可以动态返回一个属性。

```python
class Student(object):
    def __init__(self, name: str):
        self.__name = name

    def __getattr__(self, attr: any):
        # 返回 属性
        if attr == "score":
            return 99
        # 返回函数
        if attr == "name":
            return lambda : self.__name

        raise AttributeError("\'Student\' object has no attribute \'%s\'" % attr)

student = Student("Karl")
# print(student._name) #  None
print(student.score) # 99
print(student.name()) # karl
# print(student.abc)
```

注意，只有在没有找到属性的情况下，才调用__getattr__()。

这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。

```python
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__


class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

print(Chain().status.user.timeline.list) # '/status/user/timeline/list'
```

这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变。

`__call__()`

任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。

```python
class Student(object):
    def __init__(self, name):
        self.__name = name

    def __call__(self):
        print("My nameis %s." % self.__name)

Student("karl")() # My name is karl.
```


`__call__()` 还可以定义参数。

对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。

能被调用的对象就是一个Callable对象，通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。

```python
callable(Student()) # True

callable(Max) # True

callable([1, 2, 3]) # False

```

```python
class Chain(object):

    def __init__(self, path=''):
        self._path = path
        
    def __call__(self,user_name=''):
        return Chain('%s/%s' % (self._path, user_name))

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__

print(Chain().users('michael').repos) # /users/michael/repos

```
## 7.5 枚举类

当我们需要定义常量时，可以使用 `enum.Enum` ，每个常量都是class的一个唯一实例。

```python
from enum import Enum

Month = Enum("Month",("Jan", "Feb", "March", "April", "May", "June", "July", "Auguest", "September", "Octomber", "Novermber", "December"))

for name, member in Month.__members__.items():
    print(name, member,member.value)
```

可以直接使用 `Month.Jan` 来引用一个常量，或者枚举它的所有成员。

`value` 属性则是自动赋给成员的int常量，默认从 1 开始计数。

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：

```python
from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thur = 4
    Fri = 5
    Sat = 6

```

`@unique` 装饰器可以帮助我们检查保证没有重复值。

既可以用成员名称引用枚举常量，又可以直接根据 `value` 的值获得枚举常量。

```python
day1 = Weekday.Mon

print(Weekday.Mon) # Weekday.Mon
print(Weekday.Mon.value) # 1
print(Weekday(1)) # Weekday.Mon
print(day1.value) # 1

for name, member in Weekday.__members__.items():
    print(name, member, member.value)

# Sun Weekday.Sun 0
# Mon Weekday.Mon 1
# Tue Weekday.Tue 2
# Wed Weekday.Wed 3
# Thur Weekday.Thur 4
# Fri Weekday.Fri 5
# Sat Weekday.Sat 6
```

例子：

```python
from enum import Enum
from enum import unique

@unique
class Gender(Enum):
    Male = 0
    Female = 1

class Student(object):
    def __init__(self, name: str, gender: Gender):
        self.__name = name
        self.__gender = gender

    @property
    def gender(self)->Gender:
        return self.__gender

bart = Student('Bart', Gender.Male)
if bart.gender == Gender.Male:
    print('测试通过!')
else:
    print('测试失败!')
```

Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。


## 7.6 元类

### 7.6.1 type()

### 7.6.2 metaclass
